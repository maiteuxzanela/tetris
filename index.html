<!DOCTYPE html>
<html>
<head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris</title>
    <style>
                      
        body {
            background: #000;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 95vh;
        }
        #tetris {
            border: 2px solid white;
        }
	/* Estilo da imagem (ESCONDIDA INICIALMENTE) */
        #surpresa {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            display: none; /* ‚Üê Garante que a imagem comece escondida */
            opacity: 0;
            z-index: 1000;
        }
        /* Anima√ß√£o de piscar */
        .piscar {
            animation: piscar 0.3s linear 2;
        }
        @keyframes piscar {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

/* Estilo da mensagem de Game Over */
#game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #FF0D72;
    font-size: 48px;
    font-family: Arial, sans-serif;
    text-align: center;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    display: none;
    z-index: 2000;
    background: rgba(0, 0, 0, 0.8);
    padding: 20px;
    border-radius: 10px;
    animation: fadeIn 0.5s ease-out;
}

    	/* Novos estilos para controles mobile */
    	.mobile-controls {
	 position: fixed;
       	 bottom: 25px;
       	 left: 0;
         right: 0;
         display: none; /* Inicialmente escondido */
         justify-content: center;
         gap: 15px;
         padding: 10px;
         touch-action: manipulation;
   	}

    .touch-btn {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid white;
        color: white;
        font-size: 24px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .touch-btn:active {
        background: rgba(255, 255, 255, 0.4);
        transform: scale(0.9);
    }

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

    @media (max-width: 768px) {
        #tetris {
            width: 100vw;
            height: 120vh;
        }

        .mobile-controls {
            display: flex;
        }

        /* Ajusta o canvas para mobile */
        canvas {
            max-width: 100%;
            max-height: 70vh;
        }
    

      </style>
</head>
<body>
    <canvas id="tetris" width="300" height="600"></canvas>
    <img id="surpresa"  src="https://media.licdn.com/dms/image/v2/D4D03AQEhRVDyti5C8g/profile-displayphoto-shrink_800_800/profile-displayphoto-shrink_800_800/0/1728755714724?e=1743638400&v=beta&t=Ib762qFt72vY_BvkYOQHqwpXm_kH-pqBRUeWrPZLjrg" alt="Surpresa!">    

	<!-- Adicione esta div com bot√µes touch -->
    <div class="mobile-controls">
        <button class="touch-btn" id="left-btn">‚Üê</button>
        <button class="touch-btn" id="rotate-btn">‚Üª</button>
        <button class="touch-btn" id="right-btn">‚Üí</button>
        <button class="touch-btn" id="drop-btn">‚Üì</button>
    </div>	

<div id="game-over">
    <div style="font-size: 72px">üíÄ</div>
    J√° acabou???<br>
<button onclick="window.location.reload()" style="
    margin-top: 15px;
    padding: 10px 20px;
    background: #FF0D72;
    border: none;
    color: white;
    border-radius: 5px;
    cursor: pointer;
">
    Jogar Novamente
</button>
</div>

	<script>
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const BLOCK_SIZE = 30;
        const COLS = 10;
        const ROWS = 20;
        const DROP_INTERVAL = 800;
        let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        let lastDropTime = Date.now();

let gameOver = false;       

 // Cores das pe√ßas
        const COLORS = [
            '#000000', // Fundo
            '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'
        ];

        // Formatos das pe√ßas
        const SHAPES = [
            [[1, 1, 1, 1]],               // I
            [[1, 1], [1, 1]],             // O
            [[1, 1, 1], [0, 1, 0]],       // T
            [[1, 1, 1], [1, 0, 0]],       // L
            [[1, 1, 1], [0, 0, 1]],       // J
            [[1, 1, 0], [0, 1, 1]],       // S
            [[0, 1, 1], [1, 1, 0]],       // Z
        ];

        // Classe da pe√ßa
        class Piece {
            constructor(shape, color) {
                this.shape = shape;
                this.color = color;
                this.x = Math.floor(COLS / 2) - Math.floor(shape[0].length / 2);
                this.y = 0;
            }

            draw() {
                for (let row = 0; row < this.shape.length; row++) {
                    for (let col = 0; col < this.shape[row].length; col++) {
                        if (this.shape[row][col]) {
                            ctx.fillStyle = this.color;
                            ctx.fillRect(
                                (this.x + col) * BLOCK_SIZE,
                                (this.y + row) * BLOCK_SIZE,
                                BLOCK_SIZE - 1,
                                BLOCK_SIZE - 1
                            );
                        }
                    }
                }
            }

            move(dir) {
                this.x += dir;
                if (this.collision()) {
                    this.x -= dir;
                    return false;
                }
                return true;
            }

            rotate() {
                const newShape = this.shape[0].map((_, i) =>
                    this.shape.map(row => row[i]).reverse()
                );
                const oldShape = this.shape;
                this.shape = newShape;
                if (this.collision()) {
                    this.shape = oldShape;
                }
            }

            collision() {
                for (let row = 0; row < this.shape.length; row++) {
                    for (let col = 0; col < this.shape[row].length; col++) {
                        if (this.shape[row][col]) {
                            const newX = this.x + col;
                            const newY = this.y + row;
                            if (
                                newX < 0 ||
                                newX >= COLS ||
                                newY >= ROWS ||
                                board[newY][newX]
                            ) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            autoDrop() {
                const now = Date.now();
                if (now - lastDropTime > DROP_INTERVAL) {
                    this.y++;
                    lastDropTime = now;
                    return true;
                }
                return false;
            }

            hardDrop() {
                while (!this.collision()) {
                    this.y++;
                }
                this.y--; // Volta para a √∫ltima posi√ß√£o v√°lida
            }
        }

function clearLines() {
    let linesCleared = 0;
    const newBoard = [];
    
    // Filtra linhas incompletas
    for (let row = 0; row < ROWS; row++) {
        if (!board[row].every(cell => cell !== 0)) {
            newBoard.push([...board[row]]);
        } else {
            linesCleared++;
        }
    }

    // Adiciona linhas vazias no topo
    for (let i = 0; i < linesCleared; i++) {
        newBoard.unshift(Array(COLS).fill(0));
    }

    // Atualiza o tabuleiro
    board = newBoard.slice(0, ROWS);

    // Pisca a imagem se linhas foram removidas
    if (linesCleared > 0) {
        const img = document.getElementById('surpresa');
        img.style.display = 'block';
        img.classList.add('piscar');
        
        setTimeout(() => {
            img.style.display = 'none';
            img.classList.remove('piscar');
        }, 600);
    }

    return linesCleared;
}
            
        // Desenha a grade do tabuleiro
        function drawGrid() {
            ctx.strokeStyle = '#333'; // Cor das linhas de refer√™ncia
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    ctx.strokeRect(
                        col * BLOCK_SIZE,
                        row * BLOCK_SIZE,
                        BLOCK_SIZE,
                        BLOCK_SIZE
                    );
                }
            }
        }

        // Cria a primeira pe√ßa
        let piece = new Piece(
            SHAPES[Math.floor(Math.random() * SHAPES.length)],
            COLORS[Math.floor(Math.random() * (COLORS.length - 1)) + 1]
        );

      // Ajusta o tamanho do canvas para mobile
function resizeCanvas() {
    // Mant√©m as propor√ß√µes originais (300x600)
    const scale = window.innerWidth <= 768 ? 0.9 : 1;
    canvas.style.width = `${300 * scale}px`;
    canvas.style.height = `${600 * scale}px`;
    // Mant√©m o canvas n√≠tido ajustando os atributos width/height
    const dpr = window.devicePixelRatio || 1;
    canvas.width = 300 * dpr;
    canvas.height = 600 * dpr;
    ctx.scale(dpr, dpr);
}

// Inicializa e monitora redimensionamento
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Controles Touch
const touchControls = {
    left: false,
    right: false,
    rotate: false,
    drop: false
};

// Fun√ß√£o para tratamento cont√≠nuo do movimento
function handleTouchInput() {
    if (touchControls.left) piece.move(-1);
    if (touchControls.right) piece.move(1);
    if (touchControls.rotate) {
        piece.rotate();
        touchControls.rotate = false; // Reset para evitar rota√ß√£o cont√≠nua
    }
    if (touchControls.drop) piece.hardDrop();
};

// Event listeners para os bot√µes touch
document.getElementById('left-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    touchControls.left = true;
});

document.getElementById('left-btn').addEventListener('touchend', () => {
    touchControls.left = false;
});

document.getElementById('right-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    touchControls.right = true;
});

document.getElementById('right-btn').addEventListener('touchend', () => {
    touchControls.right = false;
});

document.getElementById('rotate-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    touchControls.rotate = true;
});

document.getElementById('rotate-btn').addEventListener('touchend', (e) => {
    e.preventDefault();
    touchControls.rotate = false;
});

document.getElementById('drop-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    touchControls.drop = true;
});

document.getElementById('drop-btn').addEventListener('touchend', () => {
    touchControls.drop = false;
});

       // Controles (tecla Espa√ßo adicionada)
        document.addEventListener('keydown', event => {
            switch (event.keyCode) {
                case 37: piece.move(-1); break;
                case 39: piece.move(1); break;
                case 40: 
                    piece.y++;
                    if (piece.collision()) piece.y--; 
                    break;
                case 38: piece.rotate(); break;
                case 32: // Tecla Espa√ßo (hard drop)
                    piece.hardDrop();
                    break;
            }
        });  

	// Loop do jogo
        function update() {
        if (gameOver) {
            document.getElementById('game-over').style.display = 'block';
            return;
        }

        handleTouchInput();

        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGrid();

        for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
                if (board[row][col]) {
                    ctx.fillStyle = board[row][col];
                    ctx.fillRect(
                        col * BLOCK_SIZE,
                        row * BLOCK_SIZE,
                        BLOCK_SIZE - 1,
                        BLOCK_SIZE - 1
                    );
                }
            }
        }

        piece.draw();

        const didMove = piece.autoDrop();
        if (piece.collision()) {
            piece.y--;
            for (let row = 0; row < piece.shape.length; row++) {
                for (let col = 0; col < piece.shape[row].length; col++) {
                    if (piece.shape[row][col]) {
                        board[piece.y + row][piece.x + col] = piece.color;
                    }
                }
            }
            clearLines();
            
            // Cria nova pe√ßa e verifica colis√£o imediatamente
            piece = new Piece(
                SHAPES[Math.floor(Math.random() * SHAPES.length)],
                COLORS[Math.floor(Math.random() * (COLORS.length - 1)) + 1]
            );

            // Verifica se a nova pe√ßa j√° colide (game over)
            if (piece.collision()) {
                gameOver = true;
            }
        }

        requestAnimationFrame(update);
    }

    update();     
    </script>
</body>
</html>